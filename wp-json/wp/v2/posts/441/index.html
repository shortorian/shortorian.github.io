{"id":441,"date":"2022-12-10T01:12:23","date_gmt":"2022-12-10T01:12:23","guid":{"rendered":"http:\/\/localhost\/wordpress\/?p=441"},"modified":"2023-01-11T04:10:46","modified_gmt":"2023-01-11T04:10:46","slug":"bibliograph-data-model","status":"publish","type":"post","link":"http:\/\/localhost\/wordpress\/bibliograph-data-model\/","title":{"rendered":"The bibliograph data model"},"content":{"rendered":"\n<p>I&#8217;m writing a dissertation on the history of climate science, but I&#8217;ve wound up spending a lot of my time developing a database system that can support the kind of work I need to do for the project. I&#8217;ve designed a system that solves a number of problems databases usually pose for people interested in working with complex and ambiguous source material. After looking around for similar tools for a while, and conferring with some people around the University of Washington, I think the data model is probably unique and enables some features that aren&#8217;t available in other databases. I&#8217;m implementing the database with a python package called <a href=\"https:\/\/github.com\/shortorian\/bibliograph\">bibliograph<\/a>. The first talk I gave on the project is available <a href=\"https:\/\/youtu.be\/jkQqDcneiuw?t=1233\">here<\/a> (my talk starts around minute 21). Below I outline the kind of problem this data model is meant to solve, explore my solution with an example use case, and then discuss the model as a whole. To jump straight in with a database diagram, skip to <a href=\"#bibliograph-diagram\">section 4<\/a>. The generalized version of this data model, which is not implemented in the python package I&#8217;ve written, is described in <a href=\"#generalizing-the-model\">section 6<\/a>.<\/p>\n\n\n\n<p>This post only describes the blueprint for a database, called a &#8220;data model&#8221; or &#8220;schema.&#8221; A data model is a conceptual design that doesn&#8217;t have any program code associated with it. I refer to an app that allow users to store information in a computer as a &#8220;database system&#8221; or an &#8220;implementation&#8221; of a data model (this is usually what people mean when they say &#8220;database&#8221;). If you&#8217;re unfamiliar with database concepts or terms like &#8220;string&#8221; in the context of computer programming, I&#8217;ve provided a <a href=\"#glossary\">glossary<\/a> at the end of this post. <\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"contents\">Contents<\/h2>\n\n\n\n<ol>\n<li><a href=\"#the-problem\">The problem<\/a><\/li>\n\n\n\n<li><a href=\"#an-example\">An example<\/a><\/li>\n\n\n\n<li><a href=\"#design-criteria\">Design criteria<\/a><\/li>\n\n\n\n<li><a href=\"#data-model\">The bibliograph data model<\/a><\/li>\n\n\n\n<li><a href=\"#generalizing-the-model\">Ontologies for data entry<\/a><\/li>\n\n\n\n<li><a href=\"#ontological-observations\">Generalizing the model<\/a><\/li>\n\n\n\n<li><a href=\"#glossary\">Glossary<\/a><\/li>\n<\/ol>\n\n\n\n<div class=\"is-layout-flex wp-container-3 wp-block-columns is-not-stacked-on-mobile\" id=\"the-problem\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>The problem<\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p>Databases are typically considered sources of information, but that isn&#8217;t really correct. They&#8217;re more like conduits. A database system provides a framework in which someone can make information widely available, but a database always starts out empty. People usually have to do quite a lot of labor populating a database before it&#8217;s useful to anyone. For those doing long-term research projects with a lot of sources from different places, people like historians or journalists, creating a database means finding ways to extract information from materials that weren&#8217;t designed to be represented in a computer, translating that information into a machine-readable format, and feeding it into a piece of software. As anyone with spaces or punctuation in their surname can attest, it&#8217;s very easy to lose important information in that process and wind up with a database that transmits information from external sources very badly. <\/p>\n\n\n\n<p>There&#8217;s an added complication with the materials someone like a historian or a journalist cares about: sources frequently provide conflicting or ambiguous information. From a typical database design perspective that&#8217;s a problem because data is supposed to be well-defined and <a href=\"https:\/\/en.wikipedia.org\/wiki\/Database_normalization\">normalizable<\/a>. If two sources give conflicting information about the same thing, data from one source has to be thrown out or some of the data needs to be changed to agree with the rest. This irrevocably severs the content of the database from the sources that originally contained information because databases don&#8217;t usually provide methods to link modified, normalized information with the original unmodified input that couldn&#8217;t be normalized. But historians are just as interested in who said something and why it was said as they are in the information contained in a statement. Consider a record of a nineteenth century meeting that revolutionized some scientific field; a scientist or philosopher might want to know what was discovered and how to prove it, but a historian is more likely to ask who was there and how the meeting changed their worldviews. Historians often don&#8217;t care about &#8220;the truth,&#8221; they frequently care more about what people thought was true and how their beliefs changed over time.<\/p>\n\n\n\n<p>Bibliograph is designed with this in mind &#8211; the data model can preserve all input verbatim, even if data gets normalized to different values or cleaned in some way that would destroy relations indicated by the original source material. This means a researcher can explore &#8220;true,&#8221; normalized relations abstracted from source material, but they can always back out the messy, ambiguous relations the people who made their sources might have believed were true.<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-6 wp-block-columns is-not-stacked-on-mobile\" id=\"an-example\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>An example <\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p>My approach to preserving data from external sources while creating a normalized database is to produce a graph of input data and then create a second, abstract representation of the same graph. The concepts involved are technical, so I&#8217;m going to start with an example of the kind of investigation bibliograph is designed to enable and then explain the data model itself afterwards.<\/p>\n\n\n\n<p>Imagine working through a set of notes on various sources. Each set of notes comes from an input file and each note consists of a directed link between two pieces of information. Let&#8217;s say I interview someone called Alice about someone else named Bob. I create a file called<code> alice_interview_notes.txt <\/code>and record Alice&#8217;s statements that Bob married Charles and that they worked together at a bank where everyone called Charles &#8220;Charlie.&#8221; To get these notes into a format compatible with storage in a database, I parse them into a graph of directed links as in the following diagram<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-9 wp-block-columns\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:50%\">\n<figure class=\"wp-block-image aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_input_1-1.svg\" alt=\"\" class=\"wp-image-526\" width=\"330\" height=\"240\"\/><\/figure>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:50%\">\n<figure class=\"wp-block-image aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_graph_1.svg\" alt=\"\" class=\"wp-image-527\" width=\"205\" height=\"201\"\/><\/figure>\n<\/div>\n<\/div>\n\n\n\n<p>On the left, I have a graph of relations between string values, and on the right I have an abstract graph showing entities the strings should represent, labeled by numbers. In mathematics, a graph consists of a set of &#8220;vertexes&#8221; or &#8220;nodes&#8221; which are connected by &#8220;links&#8221; or &#8220;edges.&#8221; I use &#8220;vertex&#8221; and &#8220;link&#8221; to refer to components of either graph above, while &#8220;nodes&#8221; and &#8220;edges&#8221; refer only to the abstract numbered components of the graph on the right. I call the vertexes on the left &#8220;strings&#8221; and I refer to the links as &#8220;assertions&#8221; (more on that later).<\/p>\n\n\n\n<p>Each link in my data model has a source vertex, a target vertex, a link type, and a reference vertex (references are in parentheses in the diagrams). The string graph above has four linked strings (&#8220;Bob,&#8221; &#8220;Charles,&#8221; &#8220;bank,&#8221; and &#8220;Charlie&#8221;) and two link types (&#8220;married&#8221; and &#8220;employee&#8221;). The node graph has only three vertexes because the strings &#8220;Charles&#8221; and &#8220;Charlie&#8221; should refer to the same person (&#8220;Bob&#8221; is node 1, &#8220;Charles&#8221; is 2, and &#8220;bank&#8221; is 3). The link types are the same in both cases, with &#8220;married&#8221; numbered 1 and &#8220;employee&#8221; numbered 2. The string &#8220;Alice&#8221; also corresponds to a node, number 4, but I&#8217;ve left it off the node graph because I don&#8217;t consider reference vertexes to be endpoints of links. I use reference vertexes to indicate where I should go outside the database to validate relations in a graph.<\/p>\n\n\n\n<p>Let&#8217;s say I have access to a transcript of an interview with Bob, and in that transcript he only ever discusses his wife Charlene. Initially one might assume that Alice was wrong: maybe Bob worked with Charlie at the bank, but that isn&#8217;t who he married. I could use that information to modify the node graph in the following way<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-12 wp-block-columns\">\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:50%\">\n<figure class=\"wp-block-image size-large is-resized\"><img decoding=\"async\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_input_2.svg\" alt=\"\" class=\"wp-image-528\" width=\"330\"\/><\/figure>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:50%\">\n<figure class=\"wp-block-image aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_graph_2.svg\" alt=\"\" class=\"wp-image-529\" width=\"205\" height=\"240\"\/><\/figure>\n<\/div>\n<\/div>\n\n\n\n<p>The link between Bob and Charlie (nodes 1 and 2) is dropped and a new link is created between Bob and a node representing a new person, with Bob as the reference for the new link. But further inquiries indicate this is not the correct relationship between these strings. In reality Charlene used to be called Charles, so the correct interpretation of the data at hand is shown below<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-15 wp-block-columns\">\n<div class=\"is-layout-flow wp-block-column\">\n<figure class=\"wp-block-image size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_input_3.svg\" alt=\"\" class=\"wp-image-530\" width=\"330\" height=\"335\"\/><\/figure>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\">\n<figure class=\"wp-block-image aligncenter size-large is-resized\"><img decoding=\"async\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_graph_3.svg\" alt=\"\" class=\"wp-image-531\" width=\"205\"\/><\/figure>\n<\/div>\n<\/div>\n\n\n\n<p>&#8220;Charles,&#8221; &#8220;Charlie,&#8221; and &#8220;Charlene&#8221; are all aliases for the same person, represented by node 2. The additional information from the interview with Bob is represented by a new link between nodes 1 and 2 with Bob as the reference. Later, a visit to the hall of records in the county where Bob and Charlene live turns up a marriage certificate from 2015 with the names &#8220;Bob&#8221; and &#8220;Charles,&#8221; which I can represent like this<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-18 wp-block-columns\">\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-top\" style=\"flex-basis:330px\">\n<figure class=\"wp-block-image size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_input_4.svg\" alt=\"\" class=\"wp-image-532\" width=\"264\" height=\"453\"\/><\/figure>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\">\n<figure class=\"wp-block-image aligncenter size-full is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_graph_4.svg\" alt=\"\" class=\"wp-image-533\" width=\"324\" height=\"358\"\/><\/figure>\n<\/div>\n<\/div>\n\n\n\n<p>Here I&#8217;ve chosen to represent the license with node number 7 and add links from node 7 to nodes associated with the names listed on the document (link type &#8220;licensee,&#8221; labeled 3) as well as the year of marriage. The year 2015 then gets its own node (number 8) linked to the marriage license. The labels on the links between nodes 1 and 2 would be the same as in the previous diagram, I&#8217;ve only dropped them because things are getting crowded.<\/p>\n\n\n\n<p>Finally, let&#8217;s say I&#8217;m working with a lot of marriage licenses in addition to notes from many interviews, and in the future I&#8217;d like to find all sources in my database that mention marriages by just looking at a list of links of type &#8220;married.&#8221; My notes from the hall of records might not contain a link of that type for a variety of reasons. Perhaps the notes are meant to be verbatim representations of the documents or maybe they were produced previously and I don&#8217;t want to modify the original files. What I can do is write a script that will find all the marriage certificates in my database and create a link of type &#8220;married&#8221; between the names listed on each certificate. For the marriage license above, that would correspond to a third link between nodes 1 and 2 as in the following graphs.<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-21 wp-block-columns\">\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\">\n<figure class=\"wp-block-image size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_input_5.svg\" alt=\"\" class=\"wp-image-534\" width=\"330\" height=\"100\"\/><\/figure>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column\">\n<figure class=\"wp-block-image aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_graph_5.svg\" alt=\"\" class=\"wp-image-535\" width=\"292\" height=\"322\"\/><\/figure>\n<\/div>\n<\/div>\n\n\n\n<p>My example could go on, but this is sufficient to emphasize two important features of the bibliograph schema.<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-24 wp-block-columns is-not-stacked-on-mobile\" id=\"design-criteria\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>Design criteria<\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p>First, the database representation of the content of source material must always be preserved even when new information changes the interpretation of existing data. As we saw in the example when I found an interview with Bob, the graph of strings representing the interviews can be interpreted in multiple ways. I can choose to change the way I interpret the string graph by changing how strings get mapped to nodes without affecting any of the data I&#8217;ve collected about sources.<\/p>\n\n\n\n<p>Second, the data model should make as few assumptions as possible about what kinds of things I&#8217;m trying to represent. There can be no pre-determined concept of a node &#8220;type&#8221; with specific properties because nodes are just placeholders for things the strings are supposed to name. This separation between the words used to refer to things (the strings) and the database entities meant to represent them (the nodes) allows for normalized database representations of sources with ambiguities as complex as category errors or double meanings. It also allows very different database representations of the same source materials. For instance, in the example I could have chosen to represent Charlene&#8217;s marriage with a node and then define link types connecting participants and documents to the event rather than the people who got married.<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-27 wp-block-columns is-not-stacked-on-mobile\" id=\"data-model\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>The bibliograph data model<\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p>To move from the example graphs to a database schema, let&#8217;s start by looking at the logical structure of the links between strings. Each link has a source, a target, a reference, a link type, and a string representing the input.<\/p>\n\n\n\n<figure class=\"wp-block-image aligncenter size-large is-resized\"><img decoding=\"async\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2023\/01\/bibliograph_DataModel_string_link.svg\" alt=\"\" class=\"wp-image-545\" width=\"330\"\/><\/figure>\n\n\n\n<p>As I said previously, the reference string is meant to indicate where the link came from &#8211; the place one could look outside the database to confirm this relationship. The input string allows for easy documentation of the means by which data was entered or collected. In the example above they were filenames, but they could be anything. I typically use python code snippets for input strings, indicating what function created a link and which parameters were passed into the function. One could also use an archive box number or a user name, whatever makes sense for a specific use case. For me the most important thing about the input strings is that they create a graph vertex to which I can link data about input operations. For instance, I parse links in bulk out of text files so I create links from input strings to other strings that describe different properties of the file formats.<\/p>\n\n\n\n<p>I call links between strings &#8220;assertions&#8221; &#8211; they&#8217;re meant to indicate that some source claims a connection exists between two things. To model assertions as database relations, I need to separate them from the strings because it&#8217;s very inefficient to store whole strings many times in computer memory or on disk. My basic approach is to put all the strings in one place, assign an ID number to each string, and then store assertions as sets of numbers to indicate which string is the source, the target, etc. for each assertion. The entity-relation diagram for the string graph looks like this<\/p>\n\n\n\n<figure class=\"wp-block-image aligncenter size-large\"><img decoding=\"async\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2023\/01\/bibliograph_DataModel_assertions.svg\" alt=\"\" class=\"wp-image-547\"\/><figcaption class=\"wp-element-caption\">An entity-relation diagram for the string graph. For a brief note on reading these diagrams, see the <a href=\"#e-r-diagram\">glossary<\/a>.<\/figcaption><\/figure>\n\n\n\n<p>These boxes describe tables in a database, and the lower-case labels in each box are names of columns in the tables (see the <a href=\"#e-r-diagram\">glossary<\/a> for more on the diagrams). Each row in the assertions table has an ID number for the assertion, ID numbers for each relevant string (input, source, target, and reference), an ID number pointing to a link type, and dates documenting when the assertion was created or changed. Each row in the strings<strong> <\/strong>table has an ID number for the string, a node ID indicating which node the string represents, the string value itself (&#8220;Bob&#8221; or &#8220;License 1&#8221; for example), and dates indicating when the string was added to the table and when the row was last modified. Each row in the link_types table has an ID number for the link type, a label for the type, and a field for a description.<\/p>\n\n\n\n<p>The diagram of three tables above is a blueprint for a database representation of the string graph I built up in the example. The bibliograph schema is completed by creating another three-table graph of nodes, and most of the conceptual framework for the schema is contained in the sentence, &#8220;input data consists of assertions about strings, corresponding to edges between nodes.&#8221; The complete the entity-relation diagram implemented in the bibliograph Python package is shown below.<\/p>\n\n\n\n<figure class=\"wp-block-image size-large\" id=\"bibliograph-diagram\"><img decoding=\"async\" loading=\"lazy\" width=\"930\" height=\"420\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2023\/01\/bibliograph_DataModel_erd.svg\" alt=\"\" class=\"wp-image-551\"\/><figcaption class=\"wp-element-caption\">The schema for the database I&#8217;ve implemented in my python package. For a brief note on reading database diagrams, see the <a href=\"#e-r-diagram\">glossary<\/a>.<\/figcaption><\/figure>\n\n\n\n<p>The node graph is another three-table diagram consisting of the nodes and edges tables along with a reference to the same link_types table used for the string graph. There is a node_types table included in the schema because it makes many applications much simpler, but the data model doesn&#8217;t require that nodes have types. A row in the nodes table could have no value for the node type ID in cases where a node doesn&#8217;t fit neatly into a type system, such as when a source uses a word with a double meaning. Alternatively, one could create a node type representing different kinds of ambiguities so those situations are easy to locate in the future.<\/p>\n\n\n\n<p>The link tag tables (assertion_tags and edge_tags in the diagram) allow me to create metadata and documentation for links. I use these tables to create metadata such as the position of a link in a list. For instance in my dissertation I treat the concept of &#8220;author&#8221; is a link type meant to connect a node of type &#8220;actor&#8221; to a node of type &#8220;work.&#8221; I tag each link of type &#8220;author&#8221; with a number indicating where the actor attached to the link fell in the list of authors in whatever source I&#8217;m reading so I can query the database for first and last authors of papers. I could also use tags for quick-and-dirty documentation as I build up a database. In the example I described above, if Alice had simply been wrong and Bob never married anyone named Charlie, I could have created a tags for Alice&#8217;s incorrect assertion indicating she was mistaken and noting where to look for more information. Tag tables are not required for strings or nodes because I can create an assertion of link type &#8220;tagged&#8221; and treat the assertion target as the tag for the assertion source. To tag nodes, I create an edge of type &#8220;tagged&#8221; from any kind of node to another node of type &#8220;tag.&#8221; The string representation of the edge target is then the tag I want to attach to the source node.<\/p>\n\n\n\n<p>I need two graph representations of the same data because linking a node directly to, say, the name of a person in a source is a category error. If the node is supposed to represent that person, then it is a different kind of thing than a name. The name &#8220;Charlie&#8221; is not the same thing as a person called Charlie. Databases very often avoid this error by simply assuming all unique names are also unique people. For instance, Joanne Simpson was an influential meteorologist who also published under her previous married names Joanne Malkus and Joanne Starr. If I search for Simpson in a literature database, I don&#8217;t find publications under her other names &#8211; they&#8217;re treated as different authors. I can&#8217;t proceed that way because I want to track dynamic communities of people linked together in many ways and I want to know how those communities changed over time. I solve this problem by recognizing that a name and a person are two different things and keeping them separate in the data model.<\/p>\n\n\n\n<p>Strings are related to nodes many-to-one, meaning that a node can have many string representations but every row in the strings table is attached to only one node (a string that refers to more than one thing gets repeated in multiple rows, each row containing a different node ID). Each node also has a default name and abbreviation string, but that  doesn&#8217;t change the logic of the many-to-one relation between strings and nodes. This relation means bibliograph is effectively a pair of <a href=\"https:\/\/en.wikipedia.org\/wiki\/Graph_database\">graph databases<\/a> connected many-to-one, with the string graph consisting of multiple representations of the node graph.<\/p>\n\n\n\n<p>From the perspective of someone who wants to write efficient database software, this approach is very clunky: I preserve the original representations used in my sources and then link them to nodes which stand in for the things I think the sources refer to. But it means I can start asking questions about the sources themselves rather than about abstract objects that only live in the database. Did some sources preferentially use certain names? When did Charlene start appearing under different names? These are questions some researchers need to be able to ask, and the answers would be destroyed if Charlene&#8217;s name was normalized to a standard value.<\/p>\n\n\n\n<p>Bibliograph also makes it easier to handle sources which make different assumptions about how to represent the same thing. For instance a western source might list a Chinese person&#8217;s family name in a different order than they would in their own writing, and their name could appear in multiple scripts across different sources. Those situations can all be handled with many-to-one relationships between string representations of the sources and nodes in the database corresponding to the things the strings refer to. This also applies to translations that change over time, words that might be translated incorrectly in some sources, or new words that supplant old terms. For digital sources, one could even keep strings with different <a href=\"https:\/\/en.wikipedia.org\/wiki\/Character_encoding\">character encodings<\/a> in separate tables to track how different sources handled text. With the bibliograph schema, researchers can start asking questions about what choices people made when creating different sources rather than just identifying sources with similar content.<\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-30 wp-block-columns is-not-stacked-on-mobile\" id=\"ontologies\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>Ontologies for data entry<\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p>In a schema like this one, populating the node_types and link_types tables amounts to choosing an <a href=\"https:\/\/en.wikipedia.org\/wiki\/Ontology_(information_science)\">ontology<\/a> for the database. It&#8217;s a process in which a user has to decide what things they&#8217;re representing with the database and how they fit together. In the kinds of studies bibliograph is designed for, social scientists refer to this as <a href=\"https:\/\/en.wikipedia.org\/wiki\/Coding_(social_sciences)\">coding<\/a> (not to be confused with the character encodings I mentioned above).<\/p>\n\n\n\n<p>The great advantage of my approach is that it allows people to tailor an implementation to their particular project. I work primarily with scientific papers, and as I began my project I quickly identified a data entry workflow that would be best for the kind of data product I wanted to make. I knew I needed a database that met the design criteria I described above but I couldn&#8217;t find one, so I decided to do it myself. Rather than make a lot of ad-hoc decisions about the structure of the database, choices that would turn into barriers to future work as I ran into unexpected situations in my archive, I designed a system that took both plain text input and a pair of syntax files indicating how the input should be parsed. This meant I could add new kinds of relations to the syntax files on the fly as I discovered unexpected connections in my sources, but it also meant the database had to accept anything I put into the syntax files. The bibliograph Python package is the result of that work. It takes a pair of syntax files and generates a database ontology from the input file format defined by the syntax, and the data model supporting it is designed around the meta-language of the syntax files rather than specific kinds of input. <\/p>\n\n\n\n<p>Because of this flexibility, the bibliograph data model can be used to create extremely powerful tools to translate between databases with different ontologies. <a href=\"https:\/\/en.wikipedia.org\/wiki\/Dublin_Core\">The Dublin Core metadata schema<\/a> and the <a href=\"https:\/\/en.wikipedia.org\/wiki\/CIDOC_Conceptual_Reference_Model\">CIDOC conceptual reference model<\/a> are gigantic standards meant to provide comprehensive sets of labels for objects and concepts that organizations like libraries and museums can use to create stable database representations of their collections. In the terms I&#8217;ve laid out in this post, those standards are just lists of link types and node types, so data sets from institutions that work under one of those standards can be easily converted into a form compatible with databases built on this schema. Most importantly, once information from multiple standards has been ingested into an implementation of my data model it becomes relatively straightforward to export all data in the database in a format compatible with one standard. A database built on a generalization of this model, described below, could act as a nearly universal translator (among other things). <\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-33 wp-block-columns is-not-stacked-on-mobile\" id=\"generalizing-the-model\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>Generalizing the model<\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p>The string graph in the schema above doesn&#8217;t include a vertex type like the node graph. Everything in the strings table is one kind of thing &#8211; a string. The edges table also doesn&#8217;t include a column for an input node because the bibliograph schema assumes only the string graph represents data associated directly with outside sources, while the node graph consists of abstractions the strings should refer to. The data model can be generalized by lifting the assumption that vertexes in the string graph are always strings and by providing for the possibility that nodes have their own input operations. This results in the (nearly) symmetrical diagram below.<\/p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" loading=\"lazy\" width=\"930\" height=\"420\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2023\/01\/bibliograph_erd_generalized.svg\" alt=\"\" class=\"wp-image-568\"\/><figcaption class=\"wp-element-caption\">The generalized bibliograph data model. For a brief note on reading database diagrams, see the <a href=\"#database-diagram\">glossary<\/a>.<\/figcaption><\/figure>\n\n\n\n<p>I&#8217;ve replaced the strings table with a table called &#8220;particulars.&#8221; Philosophers often make a distinction between particulars and more general things like &#8220;universals,&#8221; and here I especially have Bertrand Russell&#8217;s <a href=\"https:\/\/plato.stanford.edu\/entries\/logical-atomism\/\">logical atomism<\/a> in mind. A particular in this case is an instance of something that could be one of many particulars attached to a single node. Particulars and nodes are both categories of vertexes, so in this schema those tables both reference the vertex_types table in the same way the assertions and edges tables reference the link_types table. A column for input nodes is also added to the edges table, so I assume edges could be acquired in the same way as assertions. A one-sentence summary of the generalized data model might be &#8220;assertions about particulars are unique representations of edges between nodes.&#8221;<\/p>\n\n\n\n<p>The generalization has two major consequences. The first is that it can now represent nodes with things other than strings. Previously the node types were largely a convenience because it was assumed that input data came from statements made with words, so the assertions between strings should be intelligible and node types could be inferred that way (of course that isn&#8217;t guaranteed, so I included a node type field anyway). Vertex types in the general model are essential. A particular of vertex type &#8220;drawing&#8221; could be attached to a node of vertex type &#8220;person.&#8221; Without information about vertex types it might not be possible to infer that a particular drawing represents a person. <\/p>\n\n\n\n<p>Second, the generalized model doesn&#8217;t assume anything about particular workflows. In the constrained model I described above, I assume the graphs are always modified by creating new assertions. I never remove assertions even when new assertions indicate old ones are incorrect or should be removed from the node graph because I always want to be able to link the content of the database to the sources assertions came from. By contrast, the generalized bibliograph schema assumes the node graph might be manipulated directly. I could do things like populate the node graph and then build up particular representations of that graph afterwards or ingest graphs of nodes and particulars and then work out how particulars refer to nodes based on the content of each graph. <\/p>\n\n\n\n<div class=\"is-layout-flex wp-container-36 wp-block-columns is-not-stacked-on-mobile\" id=\"glossary\">\n<div class=\"is-layout-flow wp-block-column\" style=\"flex-basis:95%\">\n<h2>Glossary<\/h2>\n<\/div>\n\n\n\n<div class=\"is-layout-flow wp-block-column is-vertically-aligned-center\" style=\"flex-basis:5%\">\n<p class=\"has-text-align-left\"><a href=\"#contents\">\u25b2<\/a><\/p>\n<\/div>\n<\/div>\n\n\n\n<p id=\"data-model\"><strong><code>Data model<\/code><\/strong> or <strong><code>database schema<\/code><\/strong>. A <a href=\"https:\/\/en.wikipedia.org\/wiki\/Data_model\">data model<\/a> is the logical design of a database, and in this post &#8220;data model&#8221; is synonymous with &#8220;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Database_schema\">database schema<\/a>,&#8221; although others might make a distinction. There&#8217;s no code associated with it, it&#8217;s only a blueprint, so the processes by which data could be stored or retrieved according to the model are a separate issue. Bibliograph is modeled as a <a href=\"https:\/\/en.wikipedia.org\/wiki\/Relational_database\">relational database<\/a> however it relies on concepts from <a href=\"https:\/\/en.wikipedia.org\/wiki\/Navigational_database\">navigational<\/a> and <a href=\"https:\/\/en.wikipedia.org\/wiki\/Graph_database\">graph<\/a> databases.<\/p>\n\n\n\n<p id=\"e-r-diagram\"><strong><code>Entity-relation diagram<\/code><\/strong>. A diagram of a relational database often consists of a set of boxes representing tables and lines indicating references between tables. At a minimum, the boxes usually list the column labels within each table. Each row in each table represents a relation between a set of entities, hence the name. The diagrams in this post include <a href=\"https:\/\/en.wikipedia.org\/wiki\/Primary_key\">primary key<\/a> and <a href=\"https:\/\/en.wikipedia.org\/wiki\/Foreign_key\">foreign key<\/a> designations for table columns as well as <a href=\"https:\/\/en.wikipedia.org\/wiki\/Entity%E2%80%93relationship_model#Crow's_foot_notation\">crow&#8217;s foot notation<\/a> on lines between tables. The diagram below represents a many-to-many relationship between data stored in two different tables. The strings table has a column labeled string, which stores text that could be used as tags for assertions. Each row in the strings table has an ID and a string value, while the assertions table has just one column containing an ID number. The assertion_tags table contains a relationship between a string ID and an assertion ID, many-to-many, meaning that each string could be a tag for many assertions and a single assertion could have many tags. The strings and assertions tables each have a column marked as a primary key (PK) which means those columns store numbers identifying rows, while the assertion_tags table only contains columns marked as foreign keys (FK), meaning the values in those columns should be interpreted as references to primary keys in other tables.<\/p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" loading=\"lazy\" width=\"599\" height=\"94\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_DataModel_dd_example.svg\" alt=\"\" class=\"wp-image-521\"\/><\/figure>\n\n\n\n<p id=\"implementation\"><code><strong>Implementation<\/strong><\/code>. A data model is &#8220;implemented&#8221; in code somehow to create a &#8220;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Database\">database management system<\/a>,&#8221; which is what most people mean when they say &#8220;database.&#8221; The implementation provides methods to get data into computer memory in a way that&#8217;s compatible with a data model.<\/p>\n\n\n\n<p id=\"graph\"><strong><code>Graph<\/code><\/strong>. A mathematical object consisting of a set of &#8220;vertexes&#8221; or &#8220;nodes,&#8221; visualized above as circles or boxes, and &#8220;links&#8221; or &#8220;edges,&#8221; represented as lines connecting nodes. This is the &#8220;graph&#8221; from <a href=\"https:\/\/en.wikipedia.org\/wiki\/Graph_theory\">graph theory<\/a> rather than a graph of a function plotted on axes.<\/p>\n\n\n\n<p id=\"relation-table\"><strong><code>Relation<\/code><\/strong> and <strong><code>table<\/code><\/strong>. In a relational database like bibliograph, a <a href=\"https:\/\/en.wikipedia.org\/wiki\/Relation_(database)\">relation<\/a> is a connection between pieces of information represented by columns in a <a href=\"https:\/\/en.wikipedia.org\/wiki\/Table_(database)\">table<\/a>. A table is more or less identical to a spreadsheet &#8211; it has columns with labels, and rows consist of a set of individual values labeled by the column headings. Each row has an index or ID associated with it, so tables can reference values contained in other tables with a single number, which is much easier for a computer to handle than storing data in multiple places. A 10 megabyte string for instance can live in one table and every row referring to that string in any other table can just use its integer row ID rather than reproducing the whole string.<\/p>\n\n\n\n<p id=\"string\"><strong><code>String<\/code><\/strong>. A generic term for a snippet of text stored in computer memory. The representation of human-readable text in machine-readable code gets extremely complicated, so the term &#8220;string&#8221; is more abstract than something like &#8220;word&#8221; in everyday English. It refers to a precise set of symbols in a particular order. For instance the strings &#8220;bibliograph&#8221; and &#8220;Bibliograph&#8221; are distinct because small letters and capital letters are different characters. Even two strings that look identical to a human can be different according to the machine because there are many different standards for representing characters as binary numbers in memory. These standards are called <a href=\"https:\/\/en.wikipedia.org\/wiki\/Character_encoding\">character encodings<\/a>. <\/p>\n","protected":false},"excerpt":{"rendered":"<p>I&#8217;m writing a dissertation on the history of climate science, but I&#8217;ve wound up spending a lot of my time developing a database system that can support the kind of work I need to do for the project. I&#8217;ve designed a system that solves a number of problems databases usually pose for people interested in [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":626,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441"}],"collection":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/comments?post=441"}],"version-history":[{"count":104,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441\/revisions"}],"predecessor-version":[{"id":624,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441\/revisions\/624"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media\/626"}],"wp:attachment":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media?parent=441"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/categories?post=441"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/tags?post=441"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}