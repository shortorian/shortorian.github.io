{"id":441,"date":"2022-12-10T01:12:23","date_gmt":"2022-12-10T01:12:23","guid":{"rendered":"http:\/\/localhost\/wordpress\/?p=441"},"modified":"2022-12-17T01:01:58","modified_gmt":"2022-12-17T01:01:58","slug":"bibliograph-data-model","status":"publish","type":"post","link":"http:\/\/localhost\/wordpress\/bibliograph-data-model\/","title":{"rendered":"The bibliograph data model"},"content":{"rendered":"\n<p>I&#8217;m writing a dissertation on the history of climate science, but I&#8217;ve wound up spending a lot of my time developing a database system that can support the kind of work I need to do for the project. I&#8217;ve designed a data model that solves a number of problems databases usually pose for people interested in working with complex and ambiguous data sets. After looking around for similar systems for a while, and conferring with some people around the University of Washington, I think the data model is probably unique and provides some features that aren&#8217;t available in any other database. I&#8217;m implementing the database with a python package called <a href=\"https:\/\/github.com\/shortorian\/bibliograph\">bibliograph<\/a>, and I explain the data model in some detail below. The first talk I gave on the database is available <a href=\"https:\/\/youtu.be\/jkQqDcneiuw?t=1233\">here<\/a> (my talk starts around minute 21).<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\">Contents<\/h2>\n\n\n\n<ol>\n<li><a href=\"#the-problem\">The problem<\/a><\/li>\n\n\n\n<li><a href=\"#the-model\">The model<\/a><\/li>\n\n\n\n<li><a href=\"#links-strings-nodes\">Links, strings and nodes<\/a><\/li>\n\n\n\n<li><a href=\"#ues-case\">An example use case<\/a><\/li>\n\n\n\n<li><a href=\"#types\">Types<\/a><\/li>\n\n\n\n<li><a href=\"#tags\">Tags<\/a><\/li>\n<\/ol>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"the-problem\">The problem<\/h2>\n\n\n\n<p>Databases are typically considered sources of information, but that isn&#8217;t really correct. They&#8217;re more like conduits. A database system provides a framework in which someone can make information available in some useful way, but a database always starts out empty. People usually have to put in quite a lot of labor populating a database before anyone can do anything with it. For someone doing long-term research projects with a lot of source material from different places, someone like a historian or a journalist, creating a database means finding ways to extract information from materials that weren&#8217;t designed to be represented in a computer, translating that information into a machine-readable format, and feeding it into a piece of software. As anyone with spaces in their surname can attest, it&#8217;s very easy to lose important information in that process and wind up with a database that transmits information from external sources very badly. <\/p>\n\n\n\n<p>But there&#8217;s an added complication with the materials someone like a historian or a journalist cares about: sources frequently provide conflicting or ambiguous information. From a typical database design perspective that&#8217;s a problem because data is supposed to be well-defined and <a href=\"https:\/\/en.wikipedia.org\/wiki\/Database_normalization\">normalizable<\/a>. If two sources make conflicting statements about the same thing, one statement has to be thrown out or one statement needs to be changed to agree with the other. But somebody like a historian or a journalist isn&#8217;t just interested in the information content of a statement. We&#8217;re sometimes even more interested in who said something than what they said, so the fact that one of those statements was wrong could be very important. Bibliograph is designed with this in mind &#8211; the data model retains all input data verbatim, even if that data is normalized to a different value or cleaned in some way that would destroy the relationship indicated by the initial input statement. The &#8220;clean&#8221;, normalized relationships are available for queries, but you can always get the messy, ambiguous relationships back again. <\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"the-model\">The solution<\/h2>\n\n\n\n<figure class=\"wp-block-image size-full\"><img decoding=\"async\" loading=\"lazy\" width=\"1024\" height=\"462\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_1024.png\" alt=\"\" class=\"wp-image-487\" srcset=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_1024.png 1024w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_1024-300x135.png 300w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_1024-768x347.png 768w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><figcaption class=\"wp-element-caption\">The bibliograph entity relation diagram<\/figcaption><\/figure>\n\n\n\n<p>In the bibliograph data model, input statements are interpreted as assertions about string data, and the assertions and strings are abstracted into edges between nodes. An implementation of the model should provide methods to parse input into assertions and strings and then map each string to a single node, many-to-one (so &#8220;Alice Smith&#8221; and &#8220;A. Smith&#8221; could get mapped to the same node). Once unique nodes are identified, assertions between strings can be resolved into edges between nodes. Assertions include an additional relation that allows an implementation to keep complete information about the input method, so one can track not only what relationships exist in the input but how the information arrived in the database. The entity relation diagram, above, consists of two basically symmetric parts, a &#8220;string&#8221; or &#8220;input&#8221; side and a &#8220;node&#8221; side. For those familiar with the concept, this can be considered a pair of <a href=\"https:\/\/en.wikipedia.org\/wiki\/Graph_database\">graph databases<\/a>, with the string graph consisting of different representations of the node graph. <\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"links-strings-nodes\">Links, strings, and nodes<\/h2>\n\n\n\n<p>In the bibliograph schema, input statements are stored as &#8220;assertions&#8221;, which represent links between strings. An assertion is a relationship between an input string, a source string, a target string, a reference string, and a link type. Setting aside the input string for a moment, an assertion can be diagrammed like this<\/p>\n\n\n\n<figure class=\"wp-block-image aligncenter size-full\"><img decoding=\"async\" loading=\"lazy\" width=\"412\" height=\"169\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_link_diagram.png\" alt=\"\" class=\"wp-image-470\" srcset=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_link_diagram.png 412w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_link_diagram-300x123.png 300w\" sizes=\"(max-width: 412px) 100vw, 412px\" \/><\/figure>\n\n\n\n<p>The reference string is interpreted as the context for a directed link between two other strings. So in the statement &#8220;Alice said Bob married Charlie,&#8221; Alice could be the reference, Bob the source, Charlie the target, and &#8220;married&#8221; could be the link type.<\/p>\n\n\n\n<p>In <a href=\"https:\/\/github.com\/shortorian\/bibliograph\">my implementation<\/a>, the input strings are verbatim Python function calls, but they could be anything: file names, archive box numbers, whatever. The purpose is to be able to group assertions together according to the event in which they were inserted into the database. Having each assertion connected to an input operation allows me to efficiently store input metadata. For instance, if I parse a file that has elements that should be interpreted as underbar-delimited lists, I can add an assertion between the input string and the string <code><strong>\"_\"<\/strong><\/code> with link type <code><strong>list_delimiter<\/strong><\/code>. All kinds of metadata can be represented this way, so the database can be highly self-descriptive.<\/p>\n\n\n\n<p>Edges are identical to assertions except they refer to rows in the nodes table rather than the strings table, and they don&#8217;t include a relation to an input node. So an edge is a relation between a source node, a target node, a reference node, and a link type.<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"use-case\">An example use case<\/h2>\n\n\n\n<p>I developed bibliograph for my dissertation project, which includes a graph of citations from about 10,000 scientific papers. In addition to citations, I&#8217;m interested in tracking people who were acknowledged in the papers and people and institutions who contributed to data sets authors used in their work. To visualize and interpret the graphs, I need clean, normalized relations between people and papers. To understand how the papers fit into a story as historical sources, I need to be able to back out all the details of the context in which graph data originally appeared. The simplest example is personal names &#8211; people can have many different correct name representations. Joanne Simpson was an influential meteorologist for instance, and she published under three married names. I can handle this with the following set of assertions<\/p>\n\n\n\n<figure class=\"wp-block-table is-style-stripes\"><table><thead><tr><th>inp_str<\/th><th>src_str<\/th><th>tgt_str<\/th><th>ref_str<\/th><th>lnk_type<\/th><\/tr><\/thead><tbody><tr><td>A<\/td><td>joanne simpson<\/td><td>paper 1<\/td><td>paper 1<\/td><td>author<\/td><\/tr><tr><td>A<\/td><td>joanne starr<\/td><td>paper 2<\/td><td>paper 2<\/td><td>author<\/td><\/tr><tr><td>A<\/td><td>joanne malkus<\/td><td>paper 3<\/td><td>paper 3<\/td><td>author<\/td><\/tr><tr><td>B<\/td><td>simpsonj<\/td><td>joanne simpson<\/td><td>filename<\/td><td>alias<\/td><\/tr><tr><td>B<\/td><td>simpsonj<\/td><td>joanne starr<\/td><td>filename<\/td><td>alias<\/td><\/tr><tr><td>B<\/td><td>simpsonj<\/td><td>joanne malkus<\/td><td>filename<\/td><td>alias<\/td><\/tr><\/tbody><\/table><\/figure>\n\n\n\n<p>The first three rows above indicate that three published papers list Simpson as authors under three different names. The last three rows come out of a list of aliases I keep up to date as I transcribe information out of papers. When I generate nodes and edges, I have scripts that read alias assertions and map all source and target strings in a set of aliases to the same node. The aliases are ignored when creating edges, so I would normally resolve the assertions above into three edges of link type <code>author<\/code>. Information about Simpson&#8217;s authorship and the papers she wrote could then be retrieved with queries using any of the names in the table above. <\/p>\n\n\n\n<p>This approach means I can preserve relationships between sources outside the database and the information contained in the database. Nodes are abstract objects meant to stand for things in the world like people or places, things that can be represented in many ways. The sources I work with don&#8217;t contain people or places, they contain representations of them &#8211; the name &#8220;Joanne Simpson&#8221; is not the same thing as the person called Joanne Simpson. But if I can preserve the original representations used in my sources, I can start asking questions about the sources themselves rather than abstract objects that only live in the database. Did some sources preferentially use certain names? When did Simpson start appearing in print under different names? These are the kinds of questions investigators need to be able to ask, and the answers would be destroyed if Simpson&#8217;s name was normalized.<\/p>\n\n\n\n<p>Bibliograph also makes it easier to handle sources from different cultures. For instance a western source might list a Chinese person&#8217;s family name in a different order than they would in their own writing, and their name could appear in multiple scripts in different sources. Those situations are all handled with alias assertions (assuming a reasonable text encoding), and afterwards I can always back out which sources used different names for the same person. This also applies to translations that change over time, words that might be translated incorrectly in some sources, or new words introduced to replace old ones. With the bibliograph schema, researchers can start asking questions about what choices people made when creating different sources rather than just identifying sources with similar content.<\/p>\n\n\n\n<p>Finally, working with graphs in the data model is important because I don&#8217;t necessarily know ahead of time which relations I&#8217;m going to care about. In a graph, relations are stored as <code><strong>(source, target, link type)<\/strong><\/code> tuples in a single table rather than keeping different tables for different kinds of relations, so creating a new relation is as simple as adding a new link type. I can pull a lot of citation data from online indexes, but there are still around 100,000 rows of manual entry I have to do (my implementation includes an input system that allows for extremely efficient manual input, but that&#8217;s a different story), and I will certainly have new ideas and insights as I work through all those source. This approach allows me to define new relations on the fly in an input file rather than having to change the structure of the database.<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"types\">Types<\/h2>\n\n\n\n<p>An implementation of this data model, or in my implementation a user, must create what&#8217;s called a database <a href=\"https:\/\/en.wikipedia.org\/wiki\/Ontology_(information_science)\">ontology<\/a> by defining node types and link types. The bibliograph data model places no restrictions on the ontology. This means the schema can be very precisely tailored to a given application. It can be hard to explain what ontologies are, so I&#8217;ll describe one first and then talk about them more generally<\/p>\n\n\n\n<p>In the database for my dissertation, I use these node types:<\/p>\n\n\n\n<ul>\n<li><code><strong>actor<\/strong><\/code>: a person or organization<\/li>\n\n\n\n<li><code><strong>work<\/strong><\/code>: something an actor made<\/li>\n\n\n\n<li><code><strong>date<\/strong><\/code>: a point in time<\/li>\n\n\n\n<li><code><strong>identifier<\/strong><\/code>: a marker that should uniquely identify something<\/li>\n\n\n\n<li><code><strong>agreement<\/strong><\/code>: a contract between actors<\/li>\n\n\n\n<li><code><strong>acknowledgement<\/strong><\/code>: a reference in a work to another actor<\/li>\n\n\n\n<li><code><strong>affiliation<\/strong><\/code>: a reference to an actor associated with another actor<\/li>\n\n\n\n<li><code><strong>quote<\/strong><\/code>: a piece of a source I transcribed<\/li>\n\n\n\n<li><code><strong>note<\/strong><\/code>: a piece of text I want linked to something<\/li>\n\n\n\n<li><strong><code>tag<\/code><\/strong>: a piece of otherwise undefined metadata<\/li>\n<\/ul>\n\n\n\n<p>This is the set of types of things I want to link together in my project. Note that some of them could be subtypes of others &#8211; arguably everything on that list except <strong><code>actor<\/code><\/strong> qualifies as a subtype of <strong><code>work<\/code><\/strong>. But these types aren&#8217;t meant to be a logically consistent representation of the world. They were created to aid my specific research project. My approach to data entry requires that I have node types for things like agreements and acknowledgements, but it dictates that other things one might consider nodes are represented by links.<\/p>\n\n\n\n<p>For my dissertation I created these link types:<\/p>\n\n\n\n<ul>\n<li><code><strong>author<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>published<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>volume<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>page<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>doi<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>ads_bibcode<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>title<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>supertitle<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>contains<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>cited<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>affiliated<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>funded<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>acknowledged<\/strong><\/code><\/li>\n\n\n\n<li><code><strong>annotates<\/strong><\/code><\/li>\n<\/ul>\n\n\n\n<p>Again, this has inconsistencies. Why should <strong><code>volume<\/code><\/strong>, <strong><code>page<\/code><\/strong>, or <strong><code>title<\/code><\/strong> be link types when an <strong><code>affiliation<\/code><\/strong> and <strong><code>acknowledgement<\/code><\/strong> are node types? Why do I have node types <strong><code>affiliation<\/code><\/strong> and <strong><code>acknowledgement<\/code><\/strong> and also link types <strong><code>affiliated<\/code><\/strong> and <strong><code>acknowledged<\/code><\/strong>? These things are dictated exclusively by the way I&#8217;ve decided to enter data for my project. I set up a data entry format to compress large amounts of information into single lines for manual entry, and this ontology is determined by that data entry workflow. <\/p>\n\n\n\n<p>So in my case the ontology is designed to efficiently enter data I care about. But there are other approaches to ontologies. <a href=\"https:\/\/en.wikipedia.org\/wiki\/Dublin_Core\">The Dublin Core metadata schema<\/a> and the <a href=\"https:\/\/en.wikipedia.org\/wiki\/CIDOC_Conceptual_Reference_Model\">CIDOC conceptual reference model<\/a> are gigantic standards meant to provide comprehensive sets of labels for objects and concepts that organizations like libraries and museums can use to create stable database representations of their collections. The bibliograph data model doesn&#8217;t restrict the ontology, so an implementation could use the Dublin Core or CIDOC CRM standards, but that wasn&#8217;t my concern with this design. The goal here is to connect abstract entities in a database to the data sources used to create them while making as few assumptions as possible about what kind of entities and sources people work with.<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"tags\">Tags<\/h2>\n\n\n\n<p>Links sometimes require metadata. For instance, author lists are meaningful in my project and I&#8217;d like to know about first and sometimes last authors on papers. Since <strong><code>author<\/code><\/strong> is a link type in my setup, I have to attach some kind of metadata to each author link indicating that author&#8217;s position in the author list. I do that with many-to-many tables, one connecting assertions to string-valued tags and another connecting edges to nodes associated with the tags.<\/p>\n\n\n\n<p>Strings and nodes don&#8217;t need their own many-to-many tag tables. Instead, I define a link type <strong><code>tagged<\/code><\/strong> and a node type <strong><code>tag<\/code><\/strong>. An assertion can link an arbitrary string to a string representing the tag using the <code><strong>tagged<\/strong><\/code> link type. An edge of the same link type would connect the corresponding arbitrary node to the node of type <strong><code>tag<\/code><\/strong> corresponding to the tag string.<\/p>\n\n\n\n<p>This is also required for complete documentation of all information in the database. Since edges and assertions can be tagged with arbitrary metadata, they can be largely self-descriptive.<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"generalized-model\">The generalized data model<\/h2>\n\n\n\n<p>Note that as I&#8217;ve set it up here, the string-side graph doesn&#8217;t include a type for the endpoints of the links &#8211; they&#8217;re all undifferentiated strings. The fully abstract, symmetrical version of this data model would replace the strings by something more general, say &#8220;representations&#8221; as in the following diagram. In that case representations and nodes would both be instances of link endpoints, called &#8220;vertexes&#8221; below.<\/p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" loading=\"lazy\" width=\"1024\" height=\"477\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_generalized_1024-1024x477.png\" alt=\"\" class=\"wp-image-488\" srcset=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_generalized_1024-1024x477.png 1024w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_generalized_1024-300x140.png 300w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_generalized_1024-768x358.png 768w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_generalized_1024-1536x716.png 1536w, http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd_generalized_1024.png 1882w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/figure>\n\n\n\n<p>This would be a convenient way to do something like represent an actor with both names and photos. In that case the string value in the representations table could be either a natural name or the name of a file containing the photo. This would allow me to capture the fact that some sources give meaningful information about a person shown in a photo without giving any other identifying information about the person. By using a typed representations table this way, I could more easily connect sources referring to a person by name with other sources that only represented that person with a picture.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>I&#8217;m writing a dissertation on the history of climate science, but I&#8217;ve wound up spending a lot of my time developing a database system that can support the kind of work I need to do for the project. I&#8217;ve designed a data model that solves a number of problems databases usually pose for people interested [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":487,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441"}],"collection":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/comments?post=441"}],"version-history":[{"count":18,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441\/revisions"}],"predecessor-version":[{"id":489,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441\/revisions\/489"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media\/487"}],"wp:attachment":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media?parent=441"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/categories?post=441"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/tags?post=441"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}