{"id":441,"date":"2022-12-10T01:12:23","date_gmt":"2022-12-10T01:12:23","guid":{"rendered":"http:\/\/localhost\/wordpress\/?p=441"},"modified":"2022-12-10T01:34:50","modified_gmt":"2022-12-10T01:34:50","slug":"bibliograph-data-model","status":"publish","type":"post","link":"http:\/\/localhost\/wordpress\/bibliograph-data-model\/","title":{"rendered":"The bibliograph data model"},"content":{"rendered":"\n<p>I&#8217;m writing a dissertation on the history of climate science, but I&#8217;ve wound up spending a lot of my time developing a database system that can support the kind of work I need to do for my the project. I&#8217;ve designed a data model that solves a number of problems databases usually pose for people interested in working with complex and ambiguous data sets. After looking around for similar systems for a while, and conferring with some people around the University of Washington, I think the data model is probably unique and provides some features that aren&#8217;t available in any other database. I&#8217;m implementing the database with a python package called <a href=\"https:\/\/github.com\/shortorian\/bibliograph\">bibliograph<\/a>, and I explain the data model in some detail below. The first talk I gave on the database is available <a href=\"https:\/\/youtu.be\/jkQqDcneiuw?t=1233\">here<\/a> (my talk starts around minute 21).<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\">Contents<\/h2>\n\n\n\n<ol>\n<li><a href=\"#the-problem\">The problem<\/a><\/li>\n\n\n\n<li><a href=\"#the-model\">The model<\/a><\/li>\n\n\n\n<li><a href=\"#links-and-endpoints\">Links and endpoints<\/a><\/li>\n\n\n\n<li><a href=\"#ues-case\">An example use case<\/a><\/li>\n<\/ol>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"the-problem\">The problem<\/h2>\n\n\n\n<p>Databases are typically considered sources of information, but that isn&#8217;t really correct. They&#8217;re more like conduits. A database system provides a framework in which someone can make information available in some useful way, but a database always starts out empty. People usually have to put in quite a lot of labor populating a database before anyone can do anything with it. For someone doing long-term research projects with a lot of source material from different places, someone like a historian or a journalist, creating a database means finding ways to extract information from materials that weren&#8217;t designed to be represented in a computer, translating that information into a machine-readable format, and feeding it into a piece of software. As anyone with spaces in their surname can attest, it&#8217;s very easy to lose important information in that process and wind up with a database that transmits information from external sources very badly. <\/p>\n\n\n\n<p>But there&#8217;s an added complication with the materials someone like a historian or a journalist cares about: sources frequently provide conflicting or ambiguous information. From a typical database design perspective that&#8217;s a problem because data is supposed to be well-defined and <a href=\"https:\/\/en.wikipedia.org\/wiki\/Database_normalization\">normalizable<\/a>. If two sources make conflicting statements about the same thing, one statement has to be thrown out or one statement needs to be changed to agree with the other. But somebody like a historian or a journalist isn&#8217;t just interested in the information content of a statement. We&#8217;re sometimes even more interested in who said something than what they said, so the fact that one of those statements was wrong could be very important. Bibliograph is designed with this in mind &#8211; the data model retains all input data verbatim, even if that data is normalized to a different value or cleaned in some way that would destroy the relationship indicated by the initial input statement. The &#8220;clean&#8221;, normalized relationships are available for queries, but you can always get the messy, ambiguous relationships back again. <\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"the-model\">The model<\/h2>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" loading=\"lazy\" width=\"930\" height=\"420\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_erd.svg\" alt=\"\" class=\"wp-image-445\"\/><figcaption class=\"wp-element-caption\">The bibliograph entity relation diagram<\/figcaption><\/figure>\n\n\n\n<p>In bibliograph, input statements are interpreted as assertions about string data, and the assertions and strings are abstracted into edges between nodes. An implementation of the model should provide methods to parse input into assertions and strings and then map each string to a single node, many-to-one (so &#8220;Alice Smith&#8221; and &#8220;A. Smith&#8221; could get mapped to the same node). Once unique nodes are identified, assertions between strings can be resolved into edges between nodes. Assertions include an additional relation that allows an implementation to keep complete information about the input method, so one can track not only what relationships exist in the input but how the information arrived in the database. The entity relation diagram, above, consists of two basically symmetric parts, a &#8220;string&#8221; or &#8220;input&#8221; side and a &#8220;node&#8221; side. For those familiar with the concept, this can be considered a pair of <a href=\"https:\/\/en.wikipedia.org\/wiki\/Graph_database\">graph databases<\/a>, with the string graph consisting of different representations of the node graph. <\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"links-and-endpoints\">Links and endpoints<\/h2>\n\n\n\n<p>In the bibliograph schema, input statements are stored as &#8220;assertions&#8221;, which represent links between strings. An assertion is a relationship between an input string, a source string, a target string, a reference string, and a link type. Setting aside the input string for a moment, an assertion can be diagrammed like this<\/p>\n\n\n\n<figure class=\"wp-block-image aligncenter size-large\"><img decoding=\"async\" loading=\"lazy\" width=\"109\" height=\"44\" src=\"http:\/\/localhost\/wordpress\/wp-content\/uploads\/2022\/12\/bibliograph_link_diagram.svg\" alt=\"\" class=\"wp-image-456\"\/><\/figure>\n\n\n\n<p>The reference string is interpreted as the context for a directed link between two other strings. So in the statement &#8220;Alice said Bob married Charlie,&#8221; Alice could be the reference, Bob the source, Charlie the target, and &#8220;married&#8221; could be the link type. In my implementation, the input strings are verbatim Python function calls, but they could be anything: file names, archive box numbers, whatever. The purpose is to be able to group assertions together according to the event in which they were inserted into the database. Having each assertion connected to an input operation allows me to efficiently store input metadata. For instance, if I parse a file that has elements that should be interpreted as underbar-delimited lists, I can add an assertion between the input string and the string <code>\"_\"<\/code> with link type <code>list_delimiter<\/code>. All kinds of metadata can be represented this way, so the database can be highly self-descriptive.<\/p>\n\n\n\n<p>Edges are identical to assertions except they refer to rows in the nodes table rather than the strings table, and they don&#8217;t include a relation to an input node. So an edge is a relation between a source node, a target node, a reference node, and a link type.<\/p>\n\n\n\n<h2 class=\"has-x-large-font-size\" id=\"use-case\">An example use case<\/h2>\n\n\n\n<p>I developed bibliograph for my dissertation project, which includes a graph of citations from about 10,000 scientific papers. In addition to citations, I&#8217;m interested in tracking people who were acknowledged in the papers and people and institutions who contributed to data sets authors used in their work. To visualize and interpret the graphs, I need clean, normalized relations between authors and papers. To understand how the papers fit into a story as historical sources, I need to be able to back out all the details of the context in which graph data originally appeared. The simplest example is personal names &#8211; people can have many different correct name representations. Joanne Simpson was an influential meteorologist for instance, and she published under three married names. I can handle this with the following set of assertions<\/p>\n\n\n\n<figure class=\"wp-block-table is-style-stripes\"><table><thead><tr><th>inp_str<\/th><th>src_str<\/th><th>tgt_str<\/th><th>ref_str<\/th><th>lnk_type<\/th><\/tr><\/thead><tbody><tr><td>A<\/td><td>joanne simpson<\/td><td>paper 1<\/td><td>paper 1<\/td><td>author<\/td><\/tr><tr><td>A<\/td><td>joanne starr<\/td><td>paper 2<\/td><td>paper 2<\/td><td>author<\/td><\/tr><tr><td>A<\/td><td>joanne malkus<\/td><td>paper 3<\/td><td>paper 3<\/td><td>author<\/td><\/tr><tr><td>B<\/td><td>simpsonj<\/td><td>joanne simpson<\/td><td>filename<\/td><td>alias<\/td><\/tr><tr><td>B<\/td><td>simpsonj<\/td><td>joanne starr<\/td><td>filename<\/td><td>alias<\/td><\/tr><tr><td>B<\/td><td>simpsonj<\/td><td>joanne malkus<\/td><td>filename<\/td><td>alias<\/td><\/tr><\/tbody><\/table><\/figure>\n\n\n\n<p>The first three rows above indicate that three published papers list Simpson as authors under three different names. The last three rows come out of a list of aliases I keep up to date as I transcribe information out of papers. When I generate nodes and edges, I have scripts that read alias assertions and map all strings in a set of aliases to the same node. The aliases are ignored when creating edges, so I would normally resolve the assertions above into three edges that could be retrieved when searching for papers written by any of the four aliases for Simpson in the table.<\/p>\n\n\n\n<p>This system also makes it easier to handle sources from different cultures. For instance a western source might list a Chinese person&#8217;s names in a different order than they would in their own writing, and their name could appear in multiple scripts in different sources. Each of those situations is handled with the same alias approach (assuming a reasonable text encoding), and afterwards I can always back out who used what name when. The same applies to translations that change over time or words that might be translated incorrectly in some sources.<\/p>\n\n\n\n<p>Working with graphs in the data model, in which relations are stored as <code>(source, target, link type)<\/code> rather than keeping tables for different kinds of relations, is important because I don&#8217;t necessarily know ahead of time which relations I&#8217;m going to care about. I can pull a lot of citation data from online indexes, but there are still around 100,000 rows of manual entry I have to do (my implementation includes an input system that allows for extremely efficient manual input, but that&#8217;s a different story). I will certainly have new ideas and insights as I work through all those sources, and this approach allows me to define new relations on the fly in an input file rather than having to change the structure of the database.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>I&#8217;m writing a dissertation on the history of climate science, but I&#8217;ve wound up spending a lot of my time developing a database system that can support the kind of work I need to do for my the project. I&#8217;ve designed a data model that solves a number of problems databases usually pose for people [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":445,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false},"categories":[1],"tags":[],"_links":{"self":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441"}],"collection":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/comments?post=441"}],"version-history":[{"count":9,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441\/revisions"}],"predecessor-version":[{"id":459,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/posts\/441\/revisions\/459"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media\/445"}],"wp:attachment":[{"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/media?parent=441"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/categories?post=441"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/localhost\/wordpress\/wp-json\/wp\/v2\/tags?post=441"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}